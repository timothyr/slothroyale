// Generated by Haxe 3.4.7
(function ($hx_exports) { "use strict";
$hx_exports["hxGeomAlgo"] = $hx_exports["hxGeomAlgo"] || {};
$hx_exports["hxGeomAlgo"]["_HxPoint"] = $hx_exports["hxGeomAlgo"]["_HxPoint"] || {};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var Type = function() { };
Type.__name__ = true;
Type.getEnumName = function(e) {
	var a = e.__ename__;
	return a.join(".");
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
};
var hxGeomAlgo_Debug = function() { };
hxGeomAlgo_Debug.__name__ = true;
hxGeomAlgo_Debug.assert = function(cond,message,pos) {
	return;
};
var hxGeomAlgo_HomogCoord = function(x,y,w) {
	if(w == null) {
		w = 1;
	}
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
	this.w = w;
};
hxGeomAlgo_HomogCoord.__name__ = true;
hxGeomAlgo_HomogCoord.det = function(p,q,r) {
	return p.w * q.perpdot(r) - q.w * p.perpdot(r) + r.w * p.perpdot(q);
};
hxGeomAlgo_HomogCoord.ccw = function(p,q,r) {
	return hxGeomAlgo_HomogCoord.det(p,q,r) > 0;
};
hxGeomAlgo_HomogCoord.cw = function(p,q,r) {
	return hxGeomAlgo_HomogCoord.det(p,q,r) < 0;
};
hxGeomAlgo_HomogCoord.prototype = {
	add: function(p) {
		this.x += p.x;
		this.y += p.y;
		return this;
	}
	,sub: function(p) {
		this.x -= p.x;
		this.y -= p.y;
		return this;
	}
	,neg: function() {
		this.w = -this.w;
		this.x = -this.x;
		this.y = -this.y;
		return this;
	}
	,mul: function(m) {
		this.w *= m;
		this.x *= m;
		this.y *= m;
		return this;
	}
	,div: function(m) {
		this.w /= m;
		this.x /= m;
		this.y /= m;
		return this;
	}
	,normalize: function() {
		return this.div(this.length());
	}
	,lengthSquared: function() {
		return this.x * this.x + this.y * this.y;
	}
	,length: function() {
		return Math.sqrt(this.lengthSquared());
	}
	,perp: function() {
		var tmp = -this.y;
		this.y = this.x;
		this.x = tmp;
		return this;
	}
	,dotPoint: function(p) {
		return this.w + this.x * p.x + this.y * p.y;
	}
	,dot: function(p) {
		return this.w * p.w + this.x * p.x + this.y * p.y;
	}
	,perpdot: function(p) {
		return this.x * p.y - this.y * p.x;
	}
	,dotperp: function(p) {
		return -this.x * p.y + this.y * p.x;
	}
	,equals: function(p) {
		if(p.w * this.x == this.w * p.x) {
			return p.w * this.y == this.w * p.y;
		} else {
			return false;
		}
	}
	,left: function(p) {
		return this.dotPoint(p) > 0;
	}
	,right: function(p) {
		return this.dotPoint(p) < 0;
	}
	,toScreen: function() {
		return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(this.x / this.w,-this.y / this.w);
	}
	,toPoint: function() {
		return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(this.x / this.w,this.y / this.w);
	}
	,meet: function(p) {
		return new hxGeomAlgo_HomogCoord(p.w * this.y - this.w * p.y,this.w * p.x - p.w * this.x,this.x * p.y - this.y * p.x);
	}
	,meetPoint: function(p) {
		return new hxGeomAlgo_HomogCoord(this.y - this.w * p.y,this.w * p.x - this.x,this.x * p.y - this.y * p.x);
	}
	,toString: function() {
		return " (w:" + this.w + "; x:" + this.x + ", y:" + this.y + ")  ";
	}
};
var hxGeomAlgo_HxPointData = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	this.x = x;
	this.y = y;
};
hxGeomAlgo_HxPointData.__name__ = true;
hxGeomAlgo_HxPointData.prototype = {
	toString: function() {
		return "(" + this.x + ", " + this.y + ")";
	}
};
var hxGeomAlgo__$HxPoint_HxPoint_$Impl_$ = $hx_exports["hxGeomAlgo"]["_HxPoint"]["HxPoint_Impl_"] = {};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.__name__ = true;
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.get_x = function(this1) {
	return this1.x;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.set_x = function(this1,value) {
	return this1.x = value;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.get_y = function(this1) {
	return this1.y;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.set_y = function(this1,value) {
	return this1.y = value;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new = function(x,y) {
	if(y == null) {
		y = 0;
	}
	if(x == null) {
		x = 0;
	}
	var this1 = new hxGeomAlgo_HxPointData(x,y);
	return this1;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.setTo = function(this1,newX,newY) {
	this1.x = newX;
	this1.y = newY;
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.equals = function(this1,p) {
	if(p != null && this1.x == p.x) {
		return this1.y == p.y;
	} else {
		return false;
	}
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.clone = function(this1) {
	return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(this1.x,this1.y);
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.toString = function(this1) {
	return "(" + this1.x + ", " + this1.y + ")";
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.fromPointStruct = function(p) {
	return hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(p.x,p.y);
};
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.toPointStruct = function(this1) {
	return { x : this1.x, y : this1.y};
};
var hxGeomAlgo_PairDeque = function() {
	this.lastIdx = this.frontTopIdx = -1;
	this.backTopIdx = 0;
	this.front = [];
	this.back = [];
};
hxGeomAlgo_PairDeque.__name__ = true;
hxGeomAlgo_PairDeque.prototype = {
	push: function(i,j) {
		if(this.front.length <= ++this.frontTopIdx) {
			this.front.push(-1);
			this.back.push(-1);
		}
		this.front[this.frontTopIdx] = i;
		this.back[this.frontTopIdx] = j;
		this.lastIdx = this.frontTopIdx;
	}
	,pushNarrow: function(i,j) {
		if(!this.isFrontEmpty() && i <= this.frontTop()) {
			return;
		}
		while(!this.isFrontEmpty() && this.backBottom() >= j) this.popFront();
		this.push(i,j);
	}
	,isFrontEmpty: function() {
		return this.frontTopIdx < 0;
	}
	,frontHasNext: function() {
		return this.frontTopIdx > 0;
	}
	,flush: function() {
		this.lastIdx = this.frontTopIdx = -1;
	}
	,frontTop: function() {
		if(this.frontTopIdx < 0) {
			return 0;
		}
		return this.front[this.frontTopIdx];
	}
	,frontPeekNext: function() {
		return this.front[this.frontTopIdx - 1];
	}
	,backBottom: function() {
		return this.back[this.frontTopIdx];
	}
	,popFront: function() {
		return this.front[this.frontTopIdx--];
	}
	,restore: function() {
		this.backTopIdx = 0;
		this.frontTopIdx = this.lastIdx;
	}
	,isBackEmpty: function() {
		return this.backTopIdx > this.lastIdx;
	}
	,backHasNext: function() {
		return this.backTopIdx < this.lastIdx;
	}
	,frontBottom: function() {
		return this.front[this.backTopIdx];
	}
	,backPeekNext: function() {
		return this.back[this.backTopIdx + 1];
	}
	,backTop: function() {
		return this.back[this.backTopIdx];
	}
	,popBack: function() {
		return this.back[this.backTopIdx++];
	}
	,toString: function() {
		var stringBuffer_b = "";
		stringBuffer_b += Std.string("fp:" + this.frontTopIdx + ", bp:" + this.backTopIdx + ", last:" + this.lastIdx + ": ");
		var _g1 = 0;
		var _g = this.lastIdx + 1;
		while(_g1 < _g) {
			var i = _g1++;
			stringBuffer_b += Std.string(this.front[i] + "," + this.back[i] + "  ");
		}
		return stringBuffer_b;
	}
};
var hxGeomAlgo_PolyTools = $hx_exports["hxGeomAlgo"]["PolyTools"] = function() { };
hxGeomAlgo_PolyTools.__name__ = true;
hxGeomAlgo_PolyTools.isCCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g1 = 0;
	var _g = poly.length;
	while(_g1 < _g) {
		var i = _g1++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea < 0;
};
hxGeomAlgo_PolyTools.isCW = function(poly) {
	if(poly.length <= 2) {
		return true;
	}
	var signedArea = 0.;
	var _g1 = 0;
	var _g = poly.length;
	while(_g1 < _g) {
		var i = _g1++;
		var idx = i - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var idx2 = i - 1;
		var idx3 = idx2;
		var len1 = poly.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		signedArea += poly[idx].x * poly[i].y - poly[i].x * poly[idx2].y;
	}
	return signedArea > 0;
};
hxGeomAlgo_PolyTools.makeCCW = function(poly) {
	var reversed = false;
	if(!hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.makeCW = function(poly) {
	var reversed = false;
	if(hxGeomAlgo_PolyTools.isCCW(poly)) {
		poly.reverse();
		reversed = true;
	}
	return reversed;
};
hxGeomAlgo_PolyTools.isConvex = function(poly) {
	var isPositive = null;
	var _g1 = 0;
	var _g = poly.length;
	while(_g1 < _g) {
		var i = _g1++;
		var lower = i == 0 ? poly.length - 1 : i - 1;
		var middle = i;
		var upper = i == poly.length - 1 ? 0 : i + 1;
		var dx0 = poly[middle].x - poly[lower].x;
		var dy0 = poly[middle].y - poly[lower].y;
		var dx1 = poly[upper].x - poly[middle].x;
		var dy1 = poly[upper].y - poly[middle].y;
		var cross = dx0 * dy1 - dx1 * dy0;
		var newIsPositive = cross > 0;
		if(cross == 0) {
			continue;
		}
		if(isPositive == null) {
			isPositive = newIsPositive;
		} else if(isPositive != newIsPositive) {
			return false;
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.isSimple = function(poly) {
	var len = poly.length;
	if(len <= 3) {
		return true;
	}
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		var p0 = i;
		var p1 = i == len - 1 ? 0 : i + 1;
		var _g3 = i + 1;
		var _g2 = len;
		while(_g3 < _g2) {
			var j = _g3++;
			var q0 = j;
			var q1 = j == len - 1 ? 0 : j + 1;
			var intersection = hxGeomAlgo_PolyTools.segmentIntersect(poly[p0],poly[p1],poly[q0],poly[q1]);
			var tmp;
			var tmp1;
			if(intersection != null) {
				var tmp2;
				var w = poly[p0];
				var x = intersection.x - w.x;
				var x1 = intersection.y - w.y;
				if(!(Math.sqrt(x * x + x1 * x1) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w1 = poly[p1];
					var x2 = intersection.x - w1.x;
					var x3 = intersection.y - w1.y;
					tmp2 = Math.sqrt(x2 * x2 + x3 * x3) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp2 = true;
				}
				tmp1 = !tmp2;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				var tmp3;
				var w2 = poly[q0];
				var x4 = intersection.x - w2.x;
				var x5 = intersection.y - w2.y;
				if(!(Math.sqrt(x4 * x4 + x5 * x5) < hxGeomAlgo_PolyTools.EPSILON)) {
					var w3 = poly[q1];
					var x6 = intersection.x - w3.x;
					var x7 = intersection.y - w3.y;
					tmp3 = Math.sqrt(x6 * x6 + x7 * x7) < hxGeomAlgo_PolyTools.EPSILON;
				} else {
					tmp3 = true;
				}
				tmp = !tmp3;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
		}
	}
	return true;
};
hxGeomAlgo_PolyTools.segmentIntersect = function(p0,p1,q0,q1) {
	var intersectionPoint;
	var a1;
	var a2;
	var b1;
	var b2;
	var c1;
	var c2;
	a1 = p1.y - p0.y;
	b1 = p0.x - p1.x;
	c1 = p1.x * p0.y - p0.x * p1.y;
	a2 = q1.y - q0.y;
	b2 = q0.x - q1.x;
	c2 = q1.x * q0.y - q0.x * q1.y;
	var denom = a1 * b2 - a2 * b1;
	if(denom == 0) {
		return null;
	}
	intersectionPoint = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
	intersectionPoint.x = (b1 * c2 - b2 * c1) / denom;
	intersectionPoint.y = (a2 * c1 - a1 * c2) / denom;
	var x = p0.x - p1.x;
	var x1 = p0.y - p1.y;
	var p0p1 = x * x + x1 * x1;
	var x2 = q0.x - q1.x;
	var x3 = q0.y - q1.y;
	var q0q1 = x2 * x2 + x3 * x3;
	var x4 = intersectionPoint.x - p1.x;
	var x5 = intersectionPoint.y - p1.y;
	if(x4 * x4 + x5 * x5 > p0p1) {
		return null;
	}
	var x6 = intersectionPoint.x - p0.x;
	var x7 = intersectionPoint.y - p0.y;
	if(x6 * x6 + x7 * x7 > p0p1) {
		return null;
	}
	var x8 = intersectionPoint.x - q1.x;
	var x9 = intersectionPoint.y - q1.y;
	if(x8 * x8 + x9 * x9 > q0q1) {
		return null;
	}
	var x10 = intersectionPoint.x - q0.x;
	var x11 = intersectionPoint.y - q0.y;
	if(x10 * x10 + x11 * x11 > q0q1) {
		return null;
	}
	return intersectionPoint;
};
hxGeomAlgo_PolyTools.findDuplicatePoints = function(poly,consecutiveOnly,wrapAround) {
	if(wrapAround == null) {
		wrapAround = true;
	}
	if(consecutiveOnly == null) {
		consecutiveOnly = true;
	}
	var len = poly.length;
	if(len <= 1) {
		return [];
	}
	var dupIndices = [];
	var _g1 = 0;
	var _g = len - 1;
	while(_g1 < _g) {
		var i = _g1++;
		var j = i + 1;
		while(j < len) {
			var this1 = poly[i];
			var p = poly[j];
			var foundDup = p != null && this1.x == p.x && this1.y == p.y;
			if(foundDup) {
				dupIndices.push(i);
			}
			if(consecutiveOnly || foundDup && !consecutiveOnly) {
				break;
			}
			++j;
		}
	}
	var tmp;
	if(wrapAround && consecutiveOnly) {
		var this2 = poly[0];
		var p1 = poly[len - 1];
		if(p1 != null && this2.x == p1.x) {
			tmp = this2.y == p1.y;
		} else {
			tmp = false;
		}
	} else {
		tmp = false;
	}
	if(tmp) {
		dupIndices.push(len - 1);
	}
	return dupIndices;
};
hxGeomAlgo_PolyTools.intersection = function(p1,p2,q1,q2) {
	var res = null;
	var a1 = p2.y - p1.y;
	var b1 = p1.x - p2.x;
	var c1 = a1 * p1.x + b1 * p1.y;
	var a2 = q2.y - q1.y;
	var b2 = q1.x - q2.x;
	var c2 = a2 * q1.x + b2 * q1.y;
	var det = a1 * b2 - a2 * b1;
	if(!(Math.abs(det) <= hxGeomAlgo_PolyTools.EPSILON)) {
		res = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
		res.x = (b2 * c1 - b1 * c2) / det;
		res.y = (a1 * c2 - a2 * c1) / det;
	}
	return res;
};
hxGeomAlgo_PolyTools.isReflex = function(poly,idx) {
	var idx1 = idx - 1;
	var idx2 = idx1;
	var len = poly.length;
	if(idx2 < 0) {
		idx2 += len;
	}
	idx1 = idx2 % len;
	var p = poly[idx1];
	var idx3 = idx;
	var idx4 = idx3;
	var len1 = poly.length;
	if(idx4 < 0) {
		idx4 += len1;
	}
	idx3 = idx4 % len1;
	var a = poly[idx3];
	var idx5 = idx + 1;
	var idx6 = idx5;
	var len2 = poly.length;
	if(idx6 < 0) {
		idx6 += len2;
	}
	idx5 = idx6 % len2;
	var b = poly[idx5];
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.at = function(poly,idx) {
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	return poly[idx];
};
hxGeomAlgo_PolyTools.wrappedIdx = function(poly,idx) {
	var len = poly.length;
	if(idx < 0) {
		idx += len;
	}
	return idx % len;
};
hxGeomAlgo_PolyTools.side = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y);
};
hxGeomAlgo_PolyTools.isLeft = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0;
};
hxGeomAlgo_PolyTools.isLeftOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) >= 0;
};
hxGeomAlgo_PolyTools.isRight = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
};
hxGeomAlgo_PolyTools.isRightOrOn = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) <= 0;
};
hxGeomAlgo_PolyTools.isCollinear = function(p,a,b) {
	return (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) == 0;
};
hxGeomAlgo_PolyTools.distance = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return Math.sqrt(x * x + x1 * x1);
};
hxGeomAlgo_PolyTools.distanceToSegment = function(p,v,w) {
	return Math.sqrt(hxGeomAlgo_PolyTools.distanceToSegmentSquared(p,v,w));
};
hxGeomAlgo_PolyTools.distanceSquared = function(v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	return x * x + x1 * x1;
};
hxGeomAlgo_PolyTools.distanceToSegmentSquared = function(p,v,w) {
	var x = v.x - w.x;
	var x1 = v.y - w.y;
	var l2 = x * x + x1 * x1;
	if(l2 == 0) {
		var x2 = p.x - v.x;
		var x3 = p.y - v.y;
		return x2 * x2 + x3 * x3;
	}
	var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
	if(t < 0) {
		var x4 = p.x - v.x;
		var x5 = p.y - v.y;
		return x4 * x4 + x5 * x5;
	}
	if(t > 1) {
		var x6 = p.x - w.x;
		var x7 = p.y - w.y;
		return x6 * x6 + x7 * x7;
	}
	hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.setTo(hxGeomAlgo_PolyTools.point,v.x + t * (w.x - v.x),v.y + t * (w.y - v.y));
	var w1 = hxGeomAlgo_PolyTools.point;
	var x8 = p.x - w1.x;
	var x9 = p.y - w1.y;
	return x8 * x8 + x9 * x9;
};
hxGeomAlgo_PolyTools.getCentroid = function(poly) {
	var c = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
	var area = hxGeomAlgo_PolyTools.getArea(poly);
	if(area != 0) {
		var len = poly.length;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			var p0 = poly[i];
			var p1 = poly[(i + 1) % len];
			var m = p0.x * p1.y - p1.x * p0.y;
			c.x += (p0.x + p1.x) * m;
			c.y += (p0.y + p1.y) * m;
		}
		c.x /= 6 * area;
		c.y /= 6 * area;
	} else {
		c = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.EMPTY;
	}
	return c;
};
hxGeomAlgo_PolyTools.getArea = function(poly) {
	var area = 0.0;
	var len = poly.length;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		var p0 = poly[i];
		var p1 = poly[(i + 1) % len];
		area += p0.x * p1.y - p1.x * p0.y;
	}
	area = .5 * area;
	return area;
};
hxGeomAlgo_PolyTools.meet = function(p,q) {
	return new hxGeomAlgo_HomogCoord(p.y - q.y,q.x - p.x,p.x * q.y - p.y * q.x);
};
hxGeomAlgo_PolyTools.dot = function(p,q) {
	return p.x * q.x + p.y * q.y;
};
hxGeomAlgo_PolyTools.sqr = function(x) {
	return x * x;
};
hxGeomAlgo_PolyTools.eq = function(a,b) {
	return Math.abs(a - b) <= hxGeomAlgo_PolyTools.EPSILON;
};
hxGeomAlgo_PolyTools.clear = function(array) {
	array.length = 0;
};
hxGeomAlgo_PolyTools.toFloatArray = function(poly,out) {
	if(out != null) {
		out = out;
	} else {
		out = [];
	}
	var _g = 0;
	while(_g < poly.length) {
		var p = poly[_g];
		++_g;
		out.push(p.x);
		out.push(p.y);
	}
	return out;
};
hxGeomAlgo_PolyTools.reverseFloatArray = function(poly,inPlace) {
	if(inPlace == null) {
		inPlace = false;
	}
	var res = inPlace ? poly : [];
	var nPoints = poly.length >> 1;
	var _g1 = 0;
	var _g = nPoints;
	while(_g1 < _g) {
		var i = _g1++;
		var xPos = (nPoints - i - 1) * 2;
		res[i * 2] = poly[xPos];
		res[i * 2 + 1] = poly[xPos + 1];
	}
	return res;
};
hxGeomAlgo_PolyTools.flatten = function(array,out) {
	var res = out != null ? out : [];
	var _g = 0;
	while(_g < array.length) {
		var arr = array[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < arr.length) {
			var item = arr[_g1];
			++_g1;
			res.push(item);
		}
	}
	return res;
};
hxGeomAlgo_PolyTools.toPointArray = function(poly,out) {
	if(out != null) {
		out = out;
	} else {
		out = [];
	}
	var size = poly.length;
	if(poly.length % 2 == 1) {
		--size;
	}
	var _g1 = 0;
	var _g = size >> 1;
	while(_g1 < _g) {
		var i = _g1++;
		out.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(poly[i * 2],poly[i * 2 + 1]));
	}
	return out;
};
hxGeomAlgo_PolyTools.inflateLine = function(start,end,thickness) {
	var halfWidth = thickness / 2;
	var dx = end.x - start.x;
	var dy = end.y - start.y;
	var len = Math.sqrt(dx * dx + dy * dy);
	var nx = dx / len * halfWidth;
	var ny = dy / len * halfWidth;
	return [hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(start.x - ny,start.y + nx),hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(end.x - ny,end.y + nx),hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(end.x + ny,end.y - nx),hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(start.x + ny,start.y - nx)];
};
hxGeomAlgo_PolyTools.clip = function(subjPoly,clipPoly) {
	var cond = clipPoly.length >= 3 && hxGeomAlgo_PolyTools.isConvex(clipPoly);
	var res = [];
	var output = subjPoly;
	var isInside = hxGeomAlgo_PolyTools.isCCW(clipPoly) ? hxGeomAlgo_PolyTools.isRight : hxGeomAlgo_PolyTools.isLeft;
	var clipEdgeStart;
	var clipEdgeEnd;
	var inputEdgeStart;
	var inputEdgeEnd;
	var clipLen = clipPoly.length;
	var i = 0;
	var _g1 = 0;
	var _g = clipLen;
	while(_g1 < _g) {
		var i1 = _g1++;
		clipEdgeStart = clipPoly[i1];
		var idx = i1 + 1;
		var len = clipPoly.length;
		if(idx < 0) {
			idx += len;
		}
		clipEdgeEnd = clipPoly[idx % len];
		var input = output;
		output = [];
		inputEdgeStart = input[input.length - 1];
		var _g3 = 0;
		var _g2 = input.length;
		while(_g3 < _g2) {
			var j = _g3++;
			inputEdgeEnd = input[j];
			if(isInside(inputEdgeEnd,clipEdgeStart,clipEdgeEnd)) {
				if(!isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
					var intersectionPoint = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
					if(intersectionPoint != null) {
						output.push(intersectionPoint);
					}
				}
				output.push(inputEdgeEnd);
			} else if(isInside(inputEdgeStart,clipEdgeStart,clipEdgeEnd)) {
				var intersectionPoint1 = hxGeomAlgo_PolyTools.intersection(inputEdgeStart,inputEdgeEnd,clipEdgeStart,clipEdgeEnd);
				if(intersectionPoint1 != null) {
					output.push(intersectionPoint1);
				}
			}
			inputEdgeStart = inputEdgeEnd;
		}
		res.push(output);
	}
	return res;
};
hxGeomAlgo_PolyTools.exposeEnum = function(enumClass,$as) {
	var dotPath = ($as != null ? $as : Type.getEnumName(enumClass)).split(".");
	var exports = $hx_exports;
	var i = 0;
	while(i < dotPath.length - 1) {
		var currPath = dotPath[i];
		exports[currPath] = exports[currPath] || { };
		exports = exports[currPath];
		++i;
	}
	exports[dotPath[i]] = enumClass;
};
var hxGeomAlgo_SnoeyinkKeil = $hx_exports["hxGeomAlgo"]["SnoeyinkKeil"] = function() { };
hxGeomAlgo_SnoeyinkKeil.__name__ = true;
hxGeomAlgo_SnoeyinkKeil.decomposePoly = function(simplePoly) {
	var res = [];
	var indices = hxGeomAlgo_SnoeyinkKeil.decomposePolyIndices(simplePoly);
	var _g = 0;
	while(_g < indices.length) {
		var polyIndices = indices[_g];
		++_g;
		var currPoly = [];
		res.push(currPoly);
		var _g1 = 0;
		while(_g1 < polyIndices.length) {
			var idx = polyIndices[_g1];
			++_g1;
			currPoly.push(simplePoly[idx]);
		}
	}
	return res;
};
hxGeomAlgo_SnoeyinkKeil.decomposePolyIndices = function(simplePoly) {
	var res = [];
	hxGeomAlgo_SnoeyinkKeil.diagonals = [];
	if(simplePoly.length < 3) {
		return res;
	}
	hxGeomAlgo_SnoeyinkKeil.poly = [];
	var _g = 0;
	while(_g < simplePoly.length) {
		var p = simplePoly[_g];
		++_g;
		hxGeomAlgo_SnoeyinkKeil.poly.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(p.x,p.y));
	}
	hxGeomAlgo_SnoeyinkKeil.reversed = hxGeomAlgo_PolyTools.makeCW(hxGeomAlgo_SnoeyinkKeil.poly);
	var i;
	var j;
	var k;
	var n = hxGeomAlgo_SnoeyinkKeil.poly.length;
	var decomp = new hxGeomAlgo_DecompPoly(hxGeomAlgo_SnoeyinkKeil.poly);
	decomp.init();
	var _g1 = 3;
	var _g2 = n;
	while(_g1 < _g2) {
		var l = _g1++;
		i = decomp.reflexIter();
		while(i + l < n) {
			k = i + l;
			if(decomp.visible(i,k)) {
				decomp.initPairs(i,k);
				if(decomp.isReflex(k)) {
					var _g3 = i + 1;
					var _g21 = k;
					while(_g3 < _g21) {
						var j1 = _g3++;
						decomp.typeA(i,j1,k);
					}
				} else {
					j = decomp.reflexIter(i + 1);
					while(j < k - 1) {
						decomp.typeA(i,j,k);
						j = decomp.reflexNext(j);
					}
					decomp.typeA(i,k - 1,k);
				}
			}
			i = decomp.reflexNext(i);
		}
		k = decomp.reflexIter(l);
		while(k < n) {
			var tmp;
			i = k - l;
			if(!decomp.isReflex(i)) {
				tmp = decomp.visible(i,k);
			} else {
				tmp = false;
			}
			if(tmp) {
				decomp.initPairs(i,k);
				decomp.typeB(i,i + 1,k);
				j = decomp.reflexIter(i + 2);
				while(j < k) {
					decomp.typeB(i,j,k);
					j = decomp.reflexNext(j);
				}
			}
			k = decomp.reflexNext(k);
		}
	}
	decomp.guard = 3 * n;
	decomp.recoverSolution(0,n - 1);
	res = decomp.decompIndices();
	if(hxGeomAlgo_SnoeyinkKeil.reversed) {
		var _g4 = 0;
		while(_g4 < res.length) {
			var poly = res[_g4];
			++_g4;
			var _g22 = 0;
			var _g11 = poly.length;
			while(_g22 < _g11) {
				var i1 = _g22++;
				poly[i1] = n - poly[i1] - 1;
			}
		}
		var _g5 = 0;
		var _g12 = hxGeomAlgo_SnoeyinkKeil.diagonals;
		while(_g5 < _g12.length) {
			var d = _g12[_g5];
			++_g5;
			var tmp1 = d.from;
			d.from = n - d.to - 1;
			d.to = n - tmp1 - 1;
		}
	}
	return res;
};
var hxGeomAlgo_DecompPoly = function(poly) {
	this._diags = [];
	this._polys = [];
	this._indicesSet = new haxe_ds_IntMap();
	this.poly = poly;
	this.n = poly.length;
};
hxGeomAlgo_DecompPoly.__name__ = true;
hxGeomAlgo_DecompPoly.prototype = {
	init: function() {
		this.initReflex();
		this.subDecomp = new hxGeomAlgo_SubDecomp(this._reflexFlag);
		this.initVisibility();
		this.initSubProblems();
	}
	,initReflex: function() {
		this._reflexFlag = [];
		this._reflexNext = [];
		var _g1 = 0;
		var _g = this.n;
		while(_g1 < _g) {
			var i = _g1++;
			this._reflexFlag[i] = false;
			this._reflexNext[i] = -1;
		}
		var wrap = 0;
		this._reflexFlag[wrap] = true;
		var i1 = this.n - 1;
		while(i1 > 0) {
			var poly = this.poly;
			var idx = i1 - 1;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var p = poly[idx];
			var poly1 = this.poly;
			var idx2 = i1;
			var idx3 = idx2;
			var len1 = poly1.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var a = poly1[idx2];
			var poly2 = this.poly;
			var idx4 = wrap;
			var idx5 = idx4;
			var len2 = poly2.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var b = poly2[idx4];
			this._reflexFlag[i1] = (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0;
			wrap = i1;
			--i1;
		}
		this._reflexFirst = this.n;
		i1 = this.n - 1;
		while(i1 >= 0) {
			this._reflexNext[i1] = this._reflexFirst;
			if(this.isReflex(i1)) {
				this._reflexFirst = i1;
			}
			--i1;
		}
	}
	,isReflex: function(i) {
		return this._reflexFlag[i];
	}
	,reflexNext: function(i) {
		return this._reflexNext[i];
	}
	,reflexIter: function(n) {
		if(n == null || n <= 0) {
			return this._reflexFirst;
		}
		if(n > this._reflexNext.length) {
			return this._reflexNext.length;
		}
		return this._reflexNext[n - 1];
	}
	,visible: function(i,j) {
		return this.subDecomp.weight(i,j) < hxGeomAlgo_DecompPoly.BAD;
	}
	,initVisibility: function() {
		var visIndices;
		var i = this.reflexIter();
		while(i < this.n) {
			visIndices = hxGeomAlgo_Visibility.getVisibleIndicesFrom(this.poly,i);
			while(visIndices.length > 0) {
				var j = visIndices.pop();
				if(j < i) {
					this.subDecomp.setWeight(j,i,hxGeomAlgo_DecompPoly.INFINITY);
				} else {
					this.subDecomp.setWeight(i,j,hxGeomAlgo_DecompPoly.INFINITY);
				}
			}
			i = this._reflexNext[i];
		}
	}
	,setAfter: function(i) {
		var cond = this.isReflex(i);
		this.subDecomp.setWeight(i,i + 1,0);
		if(this.visible(i,i + 2)) {
			this.subDecomp.initWithWeight(i,i + 2,0,i + 1,i + 1);
		}
	}
	,setBefore: function(i) {
		var cond = this.isReflex(i);
		this.subDecomp.setWeight(i - 1,i,0);
		if(this.visible(i - 2,i)) {
			this.subDecomp.initWithWeight(i - 2,i,0,i - 1,i - 1);
		}
	}
	,initSubProblems: function() {
		var i = this.reflexIter();
		if(i == 0) {
			this.setAfter(i);
			i = this._reflexNext[i];
		}
		if(i == 1) {
			this.subDecomp.setWeight(0,1,0);
			this.setAfter(i);
			i = this._reflexNext[i];
		}
		while(i < this.n - 2) {
			this.setBefore(i);
			this.setAfter(i);
			i = this._reflexNext[i];
		}
		if(i == this.n - 2) {
			this.setBefore(i);
			this.subDecomp.setWeight(i,i + 1,0);
			i = this._reflexNext[i];
		}
		if(i == this.n - 1) {
			this.setBefore(i);
		}
	}
	,initPairs: function(i,k) {
		this.subDecomp.init(i,k);
	}
	,recoverSolution: function(i,k) {
		var j;
		this.guard--;
		var cond = this.guard >= 0;
		if(k - i <= 1) {
			return;
		}
		var pair = this.subDecomp.pairs(i,k);
		if(this.isReflex(i)) {
			j = pair.backTop();
			this.recoverSolution(j,k);
			if(j - i > 1) {
				if(pair.frontBottom() != pair.backTop()) {
					var pd = this.subDecomp.pairs(i,j);
					pd.restore();
					while(!pd.isBackEmpty() && pair.frontBottom() != pd.frontBottom()) pd.popBack();
				}
				this.recoverSolution(i,j);
			}
		} else {
			j = pair.frontTop();
			this.recoverSolution(i,j);
			if(k - j > 1) {
				if(pair.frontTop() != pair.backBottom()) {
					var pd1 = this.subDecomp.pairs(j,k);
					pd1.restore();
					while(!pd1.isFrontEmpty() && pair.backBottom() != pd1.backBottom()) pd1.popFront();
				}
				this.recoverSolution(j,k);
			}
		}
	}
	,typeA: function(i,j,k) {
		if(!this.visible(i,j)) {
			return;
		}
		var top = j;
		var w = this.subDecomp.weight(i,j);
		if(k - j > 1) {
			if(!this.visible(j,k)) {
				return;
			}
			w += this.subDecomp.weight(j,k) + 1;
		}
		if(j - i > 1) {
			var pair = this.subDecomp.pairs(i,j);
			var poly = this.poly;
			var idx = k;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var p = poly[idx];
			var poly1 = this.poly;
			var idx2 = j;
			var idx3 = idx2;
			var len1 = poly1.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var a = poly1[idx2];
			var poly2 = this.poly;
			var idx4 = pair.backTop();
			var idx5 = idx4;
			var len2 = poly2.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var b = poly2[idx4];
			if(!((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0)) {
				while(true) {
					var tmp;
					if(pair.backHasNext()) {
						var poly3 = this.poly;
						var idx6 = k;
						var idx7 = idx6;
						var len3 = poly3.length;
						if(idx7 < 0) {
							idx7 += len3;
						}
						idx6 = idx7 % len3;
						var p1 = poly3[idx6];
						var poly4 = this.poly;
						var idx8 = j;
						var idx9 = idx8;
						var len4 = poly4.length;
						if(idx9 < 0) {
							idx9 += len4;
						}
						idx8 = idx9 % len4;
						var a1 = poly4[idx8];
						var poly5 = this.poly;
						var idx10 = pair.backPeekNext();
						var idx11 = idx10;
						var len5 = poly5.length;
						if(idx11 < 0) {
							idx11 += len5;
						}
						idx10 = idx11 % len5;
						var b1 = poly5[idx10];
						tmp = !((a1.x - p1.x) * (b1.y - p1.y) - (b1.x - p1.x) * (a1.y - p1.y) > 0);
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					pair.popBack();
				}
				var tmp1;
				if(!pair.isBackEmpty()) {
					var poly6 = this.poly;
					var idx12 = k;
					var idx13 = idx12;
					var len6 = poly6.length;
					if(idx13 < 0) {
						idx13 += len6;
					}
					idx12 = idx13 % len6;
					var p2 = poly6[idx12];
					var poly7 = this.poly;
					var idx14 = i;
					var idx15 = idx14;
					var len7 = poly7.length;
					if(idx15 < 0) {
						idx15 += len7;
					}
					idx14 = idx15 % len7;
					var a2 = poly7[idx14];
					var poly8 = this.poly;
					var idx16 = pair.frontBottom();
					var idx17 = idx16;
					var len8 = poly8.length;
					if(idx17 < 0) {
						idx17 += len8;
					}
					idx16 = idx17 % len8;
					var b2 = poly8[idx16];
					tmp1 = !((a2.x - p2.x) * (b2.y - p2.y) - (b2.x - p2.x) * (a2.y - p2.y) < 0);
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					top = pair.frontBottom();
				} else {
					++w;
				}
			} else {
				++w;
			}
		}
		this.update(i,k,w,top,j);
	}
	,typeB: function(i,j,k) {
		if(!this.visible(j,k)) {
			return;
		}
		var top = j;
		var w = this.subDecomp.weight(j,k);
		if(j - i > 1) {
			if(!this.visible(i,j)) {
				return;
			}
			w += this.subDecomp.weight(i,j) + 1;
		}
		if(k - j > 1) {
			var pair = this.subDecomp.pairs(j,k);
			var poly = this.poly;
			var idx = i;
			var idx1 = idx;
			var len = poly.length;
			if(idx1 < 0) {
				idx1 += len;
			}
			idx = idx1 % len;
			var p = poly[idx];
			var poly1 = this.poly;
			var idx2 = j;
			var idx3 = idx2;
			var len1 = poly1.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var a = poly1[idx2];
			var poly2 = this.poly;
			var idx4 = pair.frontTop();
			var idx5 = idx4;
			var len2 = poly2.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var b = poly2[idx4];
			if(!((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0)) {
				while(true) {
					var tmp;
					if(pair.frontHasNext()) {
						var poly3 = this.poly;
						var idx6 = i;
						var idx7 = idx6;
						var len3 = poly3.length;
						if(idx7 < 0) {
							idx7 += len3;
						}
						idx6 = idx7 % len3;
						var p1 = poly3[idx6];
						var poly4 = this.poly;
						var idx8 = j;
						var idx9 = idx8;
						var len4 = poly4.length;
						if(idx9 < 0) {
							idx9 += len4;
						}
						idx8 = idx9 % len4;
						var a1 = poly4[idx8];
						var poly5 = this.poly;
						var idx10 = pair.frontPeekNext();
						var idx11 = idx10;
						var len5 = poly5.length;
						if(idx11 < 0) {
							idx11 += len5;
						}
						idx10 = idx11 % len5;
						var b1 = poly5[idx10];
						tmp = !((a1.x - p1.x) * (b1.y - p1.y) - (b1.x - p1.x) * (a1.y - p1.y) < 0);
					} else {
						tmp = false;
					}
					if(!tmp) {
						break;
					}
					pair.popFront();
				}
				var tmp1;
				if(!pair.isFrontEmpty()) {
					var poly6 = this.poly;
					var idx12 = i;
					var idx13 = idx12;
					var len6 = poly6.length;
					if(idx13 < 0) {
						idx13 += len6;
					}
					idx12 = idx13 % len6;
					var p2 = poly6[idx12];
					var poly7 = this.poly;
					var idx14 = k;
					var idx15 = idx14;
					var len7 = poly7.length;
					if(idx15 < 0) {
						idx15 += len7;
					}
					idx14 = idx15 % len7;
					var a2 = poly7[idx14];
					var poly8 = this.poly;
					var idx16 = pair.backBottom();
					var idx17 = idx16;
					var len8 = poly8.length;
					if(idx17 < 0) {
						idx17 += len8;
					}
					idx16 = idx17 % len8;
					var b2 = poly8[idx16];
					tmp1 = !((a2.x - p2.x) * (b2.y - p2.y) - (b2.x - p2.x) * (a2.y - p2.y) > 0);
				} else {
					tmp1 = false;
				}
				if(tmp1) {
					top = pair.backBottom();
				} else {
					++w;
				}
			} else {
				++w;
			}
		}
		this.update(i,k,w,j,top);
	}
	,update: function(a,b,w,i,j) {
		var ow = this.subDecomp.weight(a,b);
		if(w <= ow) {
			var pair = this.subDecomp.pairs(a,b);
			if(w < ow) {
				pair.flush();
				this.subDecomp.setWeight(a,b,w);
			}
			pair.pushNarrow(i,j);
		}
	}
	,_decompByDiags: function(i,k,outIndices,level) {
		if(level == null) {
			level = 0;
		}
		if(level == 0) {
			this._indicesSet.h[0] = true;
			this._indicesSet.h[this.poly.length - 1] = true;
		}
		var j;
		var ijReal = true;
		var jkReal = true;
		var nDiags = 0;
		if(k - i <= 1) {
			return;
		}
		var pair = this.subDecomp.pairs(i,k);
		if(this.isReflex(i)) {
			j = pair.backTop();
			ijReal = pair.frontBottom() == pair.backTop();
		} else {
			j = pair.frontTop();
			jkReal = pair.backBottom() == pair.frontTop();
		}
		if(ijReal) {
			this._indicesSet.h[i] = true;
			this._indicesSet.h[j] = true;
			this._diags.push({ from : i, to : j});
			++nDiags;
		}
		if(jkReal) {
			this._indicesSet.h[j] = true;
			this._indicesSet.h[k] = true;
			this._diags.push({ from : j, to : k});
			++nDiags;
		}
		this.guard--;
		var cond = this.guard >= 0;
		if(nDiags > 1) {
			var _g = [];
			var k1 = this._indicesSet.keys();
			while(k1.hasNext()) {
				var k2 = k1.next();
				_g.push(k2);
			}
			var indices = _g;
			indices.sort($bind(this,this.intCmp));
			if(indices.length > 0) {
				outIndices.push(indices);
				this._indicesSet = new haxe_ds_IntMap();
			}
		}
		if(ijReal && j - i > 1) {
			this._decompByDiags(j,k,outIndices,level + 1);
			this._decompByDiags(i,j,outIndices,level + 1);
		} else {
			this._decompByDiags(i,j,outIndices,level + 1);
			this._decompByDiags(j,k,outIndices,level + 1);
		}
	}
	,intCmp: function(a,b) {
		if(a == b) {
			return 0;
		} else if(b < a) {
			return 1;
		} else {
			return -1;
		}
	}
	,decompIndices: function() {
		var res = [];
		this.guard = 3 * this.n;
		this._decompByDiags(0,this.poly.length - 1,res);
		hxGeomAlgo_SnoeyinkKeil.diagonals = this._diags;
		return res;
	}
	,toString: function() {
		return this.poly.length + ": " + this.poly.toString();
	}
};
var hxGeomAlgo_SubDecomp = function(reflex) {
	var n = reflex.length;
	var r = 0;
	var j;
	this.rx = [];
	var _g1 = 0;
	var _g = n;
	while(_g1 < _g) {
		var i = _g1++;
		this.rx[i] = reflex[i] ? r++ : 0;
	}
	j = r;
	this.wt = [];
	this.pd = [];
	var _g11 = 0;
	var _g2 = n;
	while(_g11 < _g2) {
		var i1 = _g11++;
		if(!reflex[i1]) {
			this.rx[i1] = j++;
		}
		this.wt[i1] = [];
		this.pd[i1] = [];
		var _g3 = 0;
		var _g21 = n;
		while(_g3 < _g21) {
			var k = _g3++;
			if(i1 < r || k < r) {
				this.wt[i1][k] = hxGeomAlgo_DecompPoly.BAD;
				this.pd[i1][k] = null;
			} else {
				break;
			}
		}
	}
};
hxGeomAlgo_SubDecomp.__name__ = true;
hxGeomAlgo_SubDecomp.prototype = {
	setWeight: function(i,j,w) {
		this.wt[this.rx[i]][this.rx[j]] = w;
	}
	,weight: function(i,j) {
		return this.wt[this.rx[i]][this.rx[j]];
	}
	,pairs: function(i,j) {
		return this.pd[this.rx[i]][this.rx[j]];
	}
	,init: function(i,j) {
		return this.pd[this.rx[i]][this.rx[j]] = new hxGeomAlgo_PairDeque();
	}
	,initWithWeight: function(i,j,w,a,b) {
		this.setWeight(i,j,w);
		this.init(i,j).push(a,b);
	}
};
var hxGeomAlgo_VertexType = { __ename__ : ["hxGeomAlgo","VertexType"], __constructs__ : ["UNKNOWN","RIGHT_LID","LEFT_LID","RIGHT_WALL","LEFT_WALL"] };
hxGeomAlgo_VertexType.UNKNOWN = ["UNKNOWN",0];
hxGeomAlgo_VertexType.UNKNOWN.__enum__ = hxGeomAlgo_VertexType;
hxGeomAlgo_VertexType.RIGHT_LID = ["RIGHT_LID",1];
hxGeomAlgo_VertexType.RIGHT_LID.__enum__ = hxGeomAlgo_VertexType;
hxGeomAlgo_VertexType.LEFT_LID = ["LEFT_LID",2];
hxGeomAlgo_VertexType.LEFT_LID.__enum__ = hxGeomAlgo_VertexType;
hxGeomAlgo_VertexType.RIGHT_WALL = ["RIGHT_WALL",3];
hxGeomAlgo_VertexType.RIGHT_WALL.__enum__ = hxGeomAlgo_VertexType;
hxGeomAlgo_VertexType.LEFT_WALL = ["LEFT_WALL",4];
hxGeomAlgo_VertexType.LEFT_WALL.__enum__ = hxGeomAlgo_VertexType;
var hxGeomAlgo_Visibility = $hx_exports["hxGeomAlgo"]["Visibility"] = function() { };
hxGeomAlgo_Visibility.__name__ = true;
hxGeomAlgo_Visibility.getVisibleIndicesFrom = function(simplePoly,origIdx) {
	if(origIdx == null) {
		origIdx = 0;
	}
	var res = [];
	hxGeomAlgo_Visibility.poly = [];
	hxGeomAlgo_Visibility.stack.length = 0;
	hxGeomAlgo_Visibility.vertexType.length = 0;
	if(simplePoly.length <= 0) {
		return res;
	}
	hxGeomAlgo_Visibility.stackTop = -1;
	var _g1 = 0;
	var _g = simplePoly.length;
	while(_g1 < _g) {
		var i = _g1++;
		hxGeomAlgo_Visibility.poly.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(simplePoly[i].x,simplePoly[i].y));
		hxGeomAlgo_Visibility.stack.push(-1);
		hxGeomAlgo_Visibility.vertexType.push(hxGeomAlgo_VertexType.UNKNOWN);
	}
	hxGeomAlgo_Visibility.reversed = hxGeomAlgo_PolyTools.makeCW(hxGeomAlgo_Visibility.poly);
	if(hxGeomAlgo_Visibility.reversed) {
		origIdx = hxGeomAlgo_Visibility.poly.length - origIdx - 1;
	}
	var edgeJ;
	hxGeomAlgo_Visibility.origPoint = hxGeomAlgo_Visibility.poly[origIdx];
	var j = origIdx;
	hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_WALL);
	while(true) {
		hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_WALL);
		if(j >= hxGeomAlgo_Visibility.poly.length + origIdx) {
			break;
		}
		var poly = hxGeomAlgo_Visibility.poly;
		var idx = j - 1;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		var poly1 = hxGeomAlgo_Visibility.poly;
		var idx2 = j;
		var idx3 = idx2;
		var len1 = poly1.length;
		if(idx3 < 0) {
			idx3 += len1;
		}
		idx2 = idx3 % len1;
		edgeJ = hxGeomAlgo_PolyTools.meet(poly[idx],poly1[idx2]);
		if(edgeJ.left(hxGeomAlgo_Visibility.origPoint)) {
			if(!(j < hxGeomAlgo_Visibility.poly.length + origIdx)) {
				break;
			} else {
				continue;
			}
		}
		var poly2 = hxGeomAlgo_Visibility.poly;
		var idx4 = j - 2;
		var idx5 = idx4;
		var len2 = poly2.length;
		if(idx5 < 0) {
			idx5 += len2;
		}
		idx4 = idx5 % len2;
		if(!edgeJ.left(poly2[idx4])) {
			var poly3 = hxGeomAlgo_Visibility.poly;
			var idx6 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
			var idx7 = idx6;
			var len3 = poly3.length;
			if(idx7 < 0) {
				idx7 += len3;
			}
			idx6 = idx7 % len3;
			j = hxGeomAlgo_Visibility.exitRightBay(hxGeomAlgo_Visibility.poly,j,poly3[idx6],hxGeomAlgo_HomogCoord.INFINITY);
			hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_LID);
			if(!(j < hxGeomAlgo_Visibility.poly.length + origIdx)) {
				break;
			} else {
				continue;
			}
		}
		hxGeomAlgo_Visibility.saveLid();
		while(true) {
			var p = hxGeomAlgo_Visibility.origPoint;
			var poly4 = hxGeomAlgo_Visibility.poly;
			var idx8 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
			var idx9 = idx8;
			var len4 = poly4.length;
			if(idx9 < 0) {
				idx9 += len4;
			}
			idx8 = idx9 % len4;
			var a = poly4[idx8];
			var poly5 = hxGeomAlgo_Visibility.poly;
			var idx10 = j;
			var idx11 = idx10;
			var len5 = poly5.length;
			if(idx11 < 0) {
				idx11 += len5;
			}
			idx10 = idx11 % len5;
			var b = poly5[idx10];
			if((a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0) {
				var poly6 = hxGeomAlgo_Visibility.poly;
				var idx12 = j;
				var idx13 = idx12;
				var len6 = poly6.length;
				if(idx13 < 0) {
					idx13 += len6;
				}
				idx12 = idx13 % len6;
				var p1 = poly6[idx12];
				var poly7 = hxGeomAlgo_Visibility.poly;
				var idx14 = j + 1;
				var idx15 = idx14;
				var len7 = poly7.length;
				if(idx15 < 0) {
					idx15 += len7;
				}
				idx14 = idx15 % len7;
				var a1 = poly7[idx14];
				var b1 = hxGeomAlgo_Visibility.origPoint;
				if((a1.x - p1.x) * (b1.y - p1.y) - (b1.x - p1.x) * (a1.y - p1.y) < 0) {
					++j;
				} else {
					var poly8 = hxGeomAlgo_Visibility.poly;
					var idx16 = j + 1;
					var idx17 = idx16;
					var len8 = poly8.length;
					if(idx17 < 0) {
						idx17 += len8;
					}
					idx16 = idx17 % len8;
					if(edgeJ.left(poly8[idx16])) {
						var poly9 = hxGeomAlgo_Visibility.poly;
						var idx18 = j;
						var idx19 = idx18;
						var len9 = poly9.length;
						if(idx19 < 0) {
							idx19 += len9;
						}
						idx18 = idx19 % len9;
						var poly10 = hxGeomAlgo_Visibility.poly;
						var idx20 = hxGeomAlgo_Visibility.leftLidIdx;
						var idx21 = idx20;
						var len10 = poly10.length;
						if(idx21 < 0) {
							idx21 += len10;
						}
						idx20 = idx21 % len10;
						var poly11 = hxGeomAlgo_Visibility.poly;
						var idx22 = hxGeomAlgo_Visibility.leftLidIdx - 1;
						var idx23 = idx22;
						var len11 = poly11.length;
						if(idx23 < 0) {
							idx23 += len11;
						}
						idx22 = idx23 % len11;
						j = hxGeomAlgo_Visibility.exitLeftBay(hxGeomAlgo_Visibility.poly,j,poly9[idx18],hxGeomAlgo_PolyTools.meet(poly10[idx20],poly11[idx22])) + 1;
					} else {
						hxGeomAlgo_Visibility.restoreLid();
						hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.LEFT_WALL);
						break;
					}
				}
				var poly12 = hxGeomAlgo_Visibility.poly;
				var idx24 = j - 1;
				var idx25 = idx24;
				var len12 = poly12.length;
				if(idx25 < 0) {
					idx25 += len12;
				}
				idx24 = idx25 % len12;
				var poly13 = hxGeomAlgo_Visibility.poly;
				var idx26 = j;
				var idx27 = idx26;
				var len13 = poly13.length;
				if(idx27 < 0) {
					idx27 += len13;
				}
				idx26 = idx27 % len13;
				edgeJ = hxGeomAlgo_PolyTools.meet(poly12[idx24],poly13[idx26]);
			} else {
				var poly14 = hxGeomAlgo_Visibility.poly;
				var idx28 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
				var idx29 = idx28;
				var len14 = poly14.length;
				if(idx29 < 0) {
					idx29 += len14;
				}
				idx28 = idx29 % len14;
				if(!edgeJ.left(poly14[idx28])) {
					var poly15 = hxGeomAlgo_Visibility.poly;
					var idx30 = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
					var idx31 = idx30;
					var len15 = poly15.length;
					if(idx31 < 0) {
						idx31 += len15;
					}
					idx30 = idx31 % len15;
					j = hxGeomAlgo_Visibility.exitRightBay(hxGeomAlgo_Visibility.poly,j,poly15[idx30],edgeJ.neg());
					hxGeomAlgo_Visibility.push(j++,hxGeomAlgo_VertexType.RIGHT_LID);
					break;
				} else {
					hxGeomAlgo_Visibility.saveLid();
				}
			}
		}
		if(!(j < hxGeomAlgo_Visibility.poly.length + origIdx)) {
			break;
		}
	}
	var _g11 = 0;
	var _g2 = hxGeomAlgo_Visibility.stackTop + 1;
	while(_g11 < _g2) {
		var i1 = _g11++;
		if(hxGeomAlgo_Visibility.vertexType[i1] == hxGeomAlgo_VertexType.LEFT_WALL || hxGeomAlgo_Visibility.vertexType[i1] == hxGeomAlgo_VertexType.RIGHT_WALL) {
			var idx32 = hxGeomAlgo_Visibility.stack[i1] % hxGeomAlgo_Visibility.poly.length;
			if(hxGeomAlgo_Visibility.reversed) {
				idx32 = hxGeomAlgo_Visibility.poly.length - idx32 - 1;
			}
			res.push(idx32);
		}
	}
	return res;
};
hxGeomAlgo_Visibility.getVisiblePolyFrom = function(simplePoly,origIdx) {
	if(origIdx == null) {
		origIdx = 0;
	}
	var indices = hxGeomAlgo_Visibility.getVisibleIndicesFrom(simplePoly,origIdx);
	var res = [];
	if(indices.length <= 0) {
		return res;
	}
	var q;
	var poly = hxGeomAlgo_Visibility.poly;
	var idx = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop];
	var idx1 = idx;
	var len = poly.length;
	if(idx1 < 0) {
		idx1 += len;
	}
	idx = idx1 % len;
	var last = poly[idx];
	var lastPushed = null;
	var lastType = hxGeomAlgo_VertexType.UNKNOWN;
	var vType = hxGeomAlgo_VertexType.UNKNOWN;
	var _g1 = 0;
	var _g = hxGeomAlgo_Visibility.stackTop + 1;
	while(_g1 < _g) {
		var i = _g1++;
		vType = hxGeomAlgo_Visibility.vertexType[i];
		if(vType == hxGeomAlgo_VertexType.RIGHT_LID) {
			var q1 = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,last);
			var poly1 = hxGeomAlgo_Visibility.poly;
			var idx2 = hxGeomAlgo_Visibility.stack[i];
			var idx3 = idx2;
			var len1 = poly1.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var poly2 = hxGeomAlgo_Visibility.poly;
			var idx4 = hxGeomAlgo_Visibility.stack[i + 1];
			var idx5 = idx4;
			var len2 = poly2.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			q = q1.meet(hxGeomAlgo_PolyTools.meet(poly1[idx2],poly2[idx4]));
			if(lastPushed != null && !(last != null && lastPushed.x == last.x && lastPushed.y == last.y)) {
				res.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(last.x,last.y));
			}
			res.push(q.toPoint());
		} else if(vType == hxGeomAlgo_VertexType.LEFT_WALL) {
			var poly3 = hxGeomAlgo_Visibility.poly;
			var idx6 = hxGeomAlgo_Visibility.stack[i];
			var idx7 = idx6;
			var len3 = poly3.length;
			if(idx7 < 0) {
				idx7 += len3;
			}
			idx6 = idx7 % len3;
			var q2 = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,poly3[idx6]);
			var poly4 = hxGeomAlgo_Visibility.poly;
			var idx8 = hxGeomAlgo_Visibility.stack[i - 2];
			var idx9 = idx8;
			var len4 = poly4.length;
			if(idx9 < 0) {
				idx9 += len4;
			}
			idx8 = idx9 % len4;
			var poly5 = hxGeomAlgo_Visibility.poly;
			var idx10 = hxGeomAlgo_Visibility.stack[i - 1];
			var idx11 = idx10;
			var len5 = poly5.length;
			if(idx11 < 0) {
				idx11 += len5;
			}
			idx10 = idx11 % len5;
			q = q2.meet(hxGeomAlgo_PolyTools.meet(poly4[idx8],poly5[idx10]));
			res.push(q.toPoint());
		} else if(!(vType == hxGeomAlgo_VertexType.RIGHT_WALL && lastType == hxGeomAlgo_VertexType.RIGHT_LID || vType == hxGeomAlgo_VertexType.LEFT_LID && lastType == hxGeomAlgo_VertexType.RIGHT_LID)) {
			res.push(hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(last.x,last.y));
		}
		lastPushed = res[res.length - 1];
		var poly6 = hxGeomAlgo_Visibility.poly;
		var idx12 = hxGeomAlgo_Visibility.stack[i];
		var idx13 = idx12;
		var len6 = poly6.length;
		if(idx13 < 0) {
			idx13 += len6;
		}
		idx12 = idx13 % len6;
		last = poly6[idx12];
		lastType = vType;
	}
	return res;
};
hxGeomAlgo_Visibility.exitRightBay = function(poly,j,bot,lid) {
	var windingNum = 0;
	var mouth = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,bot);
	var lastLeft;
	var currLeft = false;
	while(++j < 3 * poly.length) {
		lastLeft = currLeft;
		var idx = j;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		currLeft = mouth.left(poly[idx]);
		var tmp;
		if(currLeft != lastLeft) {
			var idx2 = j - 1;
			var idx3 = idx2;
			var len1 = poly.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var p = poly[idx2];
			var idx4 = j;
			var idx5 = idx4;
			var len2 = poly.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var a = poly[idx4];
			var b = hxGeomAlgo_Visibility.origPoint;
			tmp = (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) > 0 == currLeft;
		} else {
			tmp = false;
		}
		if(tmp) {
			if(!currLeft) {
				--windingNum;
			} else if(windingNum++ == 0) {
				var idx6 = j - 1;
				var idx7 = idx6;
				var len3 = poly.length;
				if(idx7 < 0) {
					idx7 += len3;
				}
				idx6 = idx7 % len3;
				var idx8 = j;
				var idx9 = idx8;
				var len4 = poly.length;
				if(idx9 < 0) {
					idx9 += len4;
				}
				idx8 = idx9 % len4;
				var edge = hxGeomAlgo_PolyTools.meet(poly[idx6],poly[idx8]);
				if(edge.left(bot) && !hxGeomAlgo_HomogCoord.cw(mouth,edge,lid)) {
					return j - 1;
				}
			}
		}
	}
	var message = "ERROR: We never exited RBay " + ("(" + bot.x + ", " + bot.y + ")") + " " + Std.string(lid) + " " + windingNum;
	return j;
};
hxGeomAlgo_Visibility.exitLeftBay = function(poly,j,bot,lid) {
	var windingNum = 0;
	var mouth = hxGeomAlgo_PolyTools.meet(hxGeomAlgo_Visibility.origPoint,bot);
	var lastRight;
	var currRight = false;
	while(++j < 3 * poly.length) {
		lastRight = currRight;
		var idx = j;
		var idx1 = idx;
		var len = poly.length;
		if(idx1 < 0) {
			idx1 += len;
		}
		idx = idx1 % len;
		currRight = mouth.right(poly[idx]);
		var tmp;
		if(currRight != lastRight) {
			var idx2 = j - 1;
			var idx3 = idx2;
			var len1 = poly.length;
			if(idx3 < 0) {
				idx3 += len1;
			}
			idx2 = idx3 % len1;
			var p = poly[idx2];
			var idx4 = j;
			var idx5 = idx4;
			var len2 = poly.length;
			if(idx5 < 0) {
				idx5 += len2;
			}
			idx4 = idx5 % len2;
			var a = poly[idx4];
			var b = hxGeomAlgo_Visibility.origPoint;
			tmp = (a.x - p.x) * (b.y - p.y) - (b.x - p.x) * (a.y - p.y) < 0 == currRight;
		} else {
			tmp = false;
		}
		if(tmp) {
			if(!currRight) {
				++windingNum;
			} else if(windingNum-- == 0) {
				var idx6 = j - 1;
				var idx7 = idx6;
				var len3 = poly.length;
				if(idx7 < 0) {
					idx7 += len3;
				}
				idx6 = idx7 % len3;
				var idx8 = j;
				var idx9 = idx8;
				var len4 = poly.length;
				if(idx9 < 0) {
					idx9 += len4;
				}
				idx8 = idx9 % len4;
				var edge = hxGeomAlgo_PolyTools.meet(poly[idx6],poly[idx8]);
				if(edge.right(bot) && !hxGeomAlgo_HomogCoord.cw(mouth,edge,lid)) {
					return j - 1;
				}
			}
		}
	}
	var message = "ERROR: We never exited LBay " + ("(" + bot.x + ", " + bot.y + ")") + " " + Std.string(lid) + " " + windingNum;
	return j;
};
hxGeomAlgo_Visibility.push = function(idx,vType) {
	hxGeomAlgo_Visibility.stackTop++;
	hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop] = idx;
	hxGeomAlgo_Visibility.vertexType[hxGeomAlgo_Visibility.stackTop] = vType;
};
hxGeomAlgo_Visibility.saveLid = function() {
	if(hxGeomAlgo_Visibility.vertexType[hxGeomAlgo_Visibility.stackTop] == hxGeomAlgo_VertexType.LEFT_WALL) {
		hxGeomAlgo_Visibility.stackTop--;
	}
	hxGeomAlgo_Visibility.leftLidIdx = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop--];
	if(hxGeomAlgo_Visibility.vertexType[hxGeomAlgo_Visibility.stackTop] == hxGeomAlgo_VertexType.RIGHT_LID) {
		hxGeomAlgo_Visibility.rightLidIdx = hxGeomAlgo_Visibility.stack[hxGeomAlgo_Visibility.stackTop--];
	} else {
		hxGeomAlgo_Visibility.rightLidIdx = -1;
	}
};
hxGeomAlgo_Visibility.restoreLid = function() {
	if(hxGeomAlgo_Visibility.rightLidIdx != -1) {
		hxGeomAlgo_Visibility.push(hxGeomAlgo_Visibility.rightLidIdx,hxGeomAlgo_VertexType.RIGHT_LID);
	}
	hxGeomAlgo_Visibility.push(hxGeomAlgo_Visibility.leftLidIdx,hxGeomAlgo_VertexType.LEFT_LID);
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
hxGeomAlgo_HomogCoord.INFINITY = new hxGeomAlgo_HomogCoord();
hxGeomAlgo__$HxPoint_HxPoint_$Impl_$.EMPTY = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(NaN,NaN);
hxGeomAlgo_PolyTools.point = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new();
hxGeomAlgo_PolyTools.zero = hxGeomAlgo__$HxPoint_HxPoint_$Impl_$._new(0,0);
hxGeomAlgo_PolyTools.EPSILON = .00000001;
hxGeomAlgo_DecompPoly.INFINITY = 100000;
hxGeomAlgo_DecompPoly.BAD = 999990;
hxGeomAlgo_DecompPoly.NONE = 0;
hxGeomAlgo_Visibility.NOT_SAVED = -1;
hxGeomAlgo_Visibility.stack = [];
hxGeomAlgo_Visibility.vertexType = [];
})(typeof exports != "undefined" ? module.exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
